#pragma config(Sensor, in1,    vis1,           sensorReflection)
#pragma config(Sensor, in2,    inf1,           sensorLineFollower)
#pragma config(Sensor, in3,    inf2,           sensorLineFollower)
#pragma config(Motor,  port1,           led1,          tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define L 100

int type;

int vAvg;
int iAvg;

int dist;
int minDist;
int bestMatch;

int vSum;
int iSum;

int vArr[L];
int iArr[L];

enum label { Empty, Blue, Metal, White, Bite, Wood, Clear, N };
int data[N][2] = {
	{  107,   84},
	{  578, 1423},
	{ 2609, 1119},
	{  875,  957},
	{  416, 1145},
	{ 2742,  623},
	{  112, 1229},
};
int vNorm = 300;
int iNorm = 4000;

int square(int n){
	return n*n;
}


task main()
{
	motor[port1] = -127;

	while(true){
		for(int i = 0; i < L-1; i++){
			vArr[i] = vArr[i+1];
			iArr[i] = iArr[i+1];
		}
		vArr[L-1] = SensorValue[vis1];
		iArr[L-1] = SensorValue[inf1] + SensorValue[inf2];

		vSum = 0;
		iSum = 0;
		for(int i = 0; i < L-1; i++){
			vSum += vArr[i];
			iSum += iArr[i];
		}
		vAvg = vSum * 1000 / vNorm / L;
		iAvg = iSum * 1000 / iNorm / L;

		minDist = 100000000;
		bestMatch = 0;
		for(int i = 0; i < (int)N-1; i++){
			dist = square(vAvg - data[i][0]) + square(iAvg - data[i][1]);
			if(dist < minDist){
				minDist = dist;
				bestMatch = i;
			}
		}
		type = bestMatch;
	}
}
