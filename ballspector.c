#pragma config(Sensor, in1,    vis1,           sensorReflection)
#pragma config(Sensor, in2,    inf1,           sensorLineFollower)
#pragma config(Sensor, in3,    inf2,           sensorLineFollower)
#pragma config(Sensor, dgtl10, ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl12, ,               sensorQuadEncoder)
#pragma config(Motor,  port1,           led1,          tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port10,          mot1,          tmotorVex269_HBridge, openLoop, encoderPort, dgtl12)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define L 100

int type;

int dist;
int minDist;
int bestMatch;

int nSamples = 100;
enum sensor { Vis, Inf, nSensors };
enum material { Empty, Blue, Metal, White, Bite, Wood, Clear, nMaterials };

// Known material data to match against
int known[nMaterials][2] = {
	{  107,   84},
	{  578, 1423},
	{ 2609, 1119},
	{  875,  957},
	{  416, 1145},
	{ 2742,  623},
	{  112, 1229},
};
// Normalization factors for converting sensor data to same range as knowns
int norm[nSensors] = { 300, 4000 };


//
int arr[L][nSensors];
int index;
int avg[nSensors];
int sum[nSensors];


int square(int n){
	return n*n;
}


task main()
{
	motor[port1] = -127;
	motor[port10] = 128;
	wait(1);
	motor[port10] = 0;

	while(true){

		arr[index][Vis] = SensorValue[vis1];
		arr[index][Inf] = SensorValue[inf1] + SensorValue[inf2];
		index++;
		index %= L;

		sum[Vis] = 0;
		sum[Inf] = 0;
		for(int i = 0; i < L-1; i++){
			sum[Vis] += arr[i][Vis];
			sum[Inf] += arr[i][Inf];
		}
		avg[Vis] = sum[Vis] * 1000 / norm[Vis] / L;
		avg[Inf] = sum[Inf] * 1000 / norm[Inf] / L;

		minDist = 100000000;
		bestMatch = 0;
		for(int i = 0; i < (int)nMaterials - 1; i++){
			dist = square(avg[Vis] - known[i][Vis]) + square(avg[Inf] - known[i][Inf]);
			if(dist < minDist){
				minDist = dist;
				bestMatch = i;
			}
		}
		type = bestMatch;
	}
}
