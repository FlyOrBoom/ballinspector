#pragma config(Sensor, in1,    vis1,           sensorReflection)
#pragma config(Sensor, in2,    inf1,           sensorLineFollower)
#pragma config(Sensor, in3,    inf2,           sensorLineFollower)
#pragma config(Sensor, dgtl11, enc1,           sensorQuadEncoder)
#pragma config(Motor,  port1,           led1,          tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port10,          mot1,          tmotorVex269_HBridge, openLoop, encoderPort, dgtl11)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define L 100

int angle;

int type;

int dist;
int minDist;
int bestMatch;

int nSamples = 100;
enum sensor { Vis, Inf, nSensors };
enum material { Empty, Blue, Metal, White, Bite, Wood, Clear, nMaterials };

// Known material data to match against
int known[nMaterials][2] = {
	{  107,   84},
	{  578, 1423},
	{ 2609, 1119},
	{  875,  957},
	{  416, 1145},
	{ 2742,  623},
	{  112, 1229},
};
// Normalization factors for converting sensor data to same range as knowns
int norm[nSensors] = { 300, 4000 };


// Averaging an array of sensor values
int arr[L][nSensors];
int index;
int avg[nSensors];
int sum[nSensors];



int square(int n)
{
	return n*n;
}

void raise()
{
	moveMotorTarget(mot1, 0, 128, true);
	sleep(2);
}

void lower()
{
	moveMotorTarget(mot1, -100, 128, true);
	sleep(2);
}

task main()
{
	motor[led1] = -127; // Turn on flashlight

	while(true)
	{
		raise();
		resetTimer(T1);

		while(time1[T1] < 1000 || type == 0)
		{
			arr[index][Vis] = SensorValue[vis1];
			arr[index][Inf] = SensorValue[inf1] + SensorValue[inf2];
			index++;
			index %= L;

			sum[Vis] = 0;
			sum[Inf] = 0;

			for(int i = 0; i < L-1; i++)
			{
				sum[Vis] += arr[i][Vis];
				sum[Inf] += arr[i][Inf];
			}

			avg[Vis] = sum[Vis] * 1000 / norm[Vis] / L;
			avg[Inf] = sum[Inf] * 1000 / norm[Inf] / L;

			minDist = 100000000;
			type = 0;

			for(int i = 0; i < (int)nMaterials - 1; i++)
			{
				dist = square(avg[Vis] - known[i][Vis]) + square(avg[Inf] - known[i][Inf]);

				if(dist < minDist)
				{
					minDist = dist;
					type = i;
				}
			}

		}
		lower();
	}
}
