#pragma config(Sensor, in1,    vis1,           sensorReflection)
#pragma config(Sensor, in2,    inf1,           sensorLineFollower)
#pragma config(Sensor, in3,    inf2,           sensorLineFollower)
#pragma config(Sensor, dgtl10, ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl12, ,               sensorQuadEncoder)
#pragma config(Motor,  port1,           led1,          tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port10,          mot1,          tmotorVex269_HBridge, openLoop, encoderPort, dgtl12)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int dist;
int minDist;
int bestMatch;

enum material { Empty, Blue, Metal, White, Bite, Wood, Clear, nMaterials };

// Sampling from both visible and infrared
enum sensor { Vis, Inf, nSensors };
int nSamples = 100;
int arr[nSamples][nSensors];
int iSample;
int avg[nSensors];
int sum[nSensors];

// Known material data to match against
int known[nMaterials][2] = {
	{  107,   84},
	{  578, 1423},
	{ 2609, 1119},
	{  875,  957},
	{  416, 1145},
	{ 2742,  623},
	{  112, 1229},
};
// Normalization factors for converting sensor data to same range as knowns
int norm[nSensors] = { 300, 4000 };


int square(int n){
	return n*n;
}


task main()
{
	motor[port1] = -127;
	motor[port10] = 128;
	wait(1);
	motor[port10] = 0;

	while(true){

		arr[iSample][Vis] = SensorValue[vis1];
		arr[iSample][Inf] = SensorValue[inf1] + SensorValue[inf2];
		iSample++;
		iSample %= L;

		sum[Vis] = 0;
		sum[Inf] = 0;
		for(int i = 0; i < nSamples; i++){
			sum[Vis] += arr[i][Vis];
			sum[Inf] += arr[i][Inf];
		}
		avg[Vis] = sum[Vis] * 1000 / norm[Vis] / nSamples;
		avg[Inf] = sum[Inf] * 1000 / norm[Inf] / nSamples;

		minDist = 100000000;
		bestMatch = 0;
		for(int i = 0; i < nMaterials; i++){
			dist = square(avg[Vis] - known[i][Vis]) + square(avg[Inf] - known[i][Inf]);
			if(dist < minDist){
				minDist = dist;
				bestMatch = i;
			}
		}
	}
}
